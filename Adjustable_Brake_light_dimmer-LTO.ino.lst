
C:\Windows\Users1\Users\WINDOWS\AppData\Local\Temp\arduino_build_445663/Adjustable_Brake_light_dimmer.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	17 c0       	rjmp	.+46     	; 0x30 <__ctors_end>
   2:	26 c0       	rjmp	.+76     	; 0x50 <__bad_interrupt>
   4:	25 c0       	rjmp	.+74     	; 0x50 <__bad_interrupt>
   6:	24 c0       	rjmp	.+72     	; 0x50 <__bad_interrupt>
   8:	c1 c0       	rjmp	.+386    	; 0x18c <__vector_4>
   a:	22 c0       	rjmp	.+68     	; 0x50 <__bad_interrupt>
   c:	21 c0       	rjmp	.+66     	; 0x50 <__bad_interrupt>
   e:	20 c0       	rjmp	.+64     	; 0x50 <__bad_interrupt>
  10:	1f c0       	rjmp	.+62     	; 0x50 <__bad_interrupt>
  12:	1e c0       	rjmp	.+60     	; 0x50 <__bad_interrupt>
  14:	1d c0       	rjmp	.+58     	; 0x50 <__bad_interrupt>
  16:	1c c0       	rjmp	.+56     	; 0x50 <__bad_interrupt>
  18:	1b c0       	rjmp	.+54     	; 0x50 <__bad_interrupt>
  1a:	1a c0       	rjmp	.+52     	; 0x50 <__bad_interrupt>
  1c:	19 c0       	rjmp	.+50     	; 0x50 <__bad_interrupt>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	00 36       	cpi	r16, 0x60	; 96

00000020 <port_to_mode_PGM>:
  20:	00 37                                               .7

00000022 <port_to_output_PGM>:
  22:	00 38                                               .8

00000024 <digital_pin_to_port_PGM>:
  24:	01 01 01 01 01 01                                   ......

0000002a <digital_pin_to_bit_mask_PGM>:
  2a:	01 02 04 08 10 20                                   ..... 

00000030 <__ctors_end>:
__dtors_end():
  30:	11 24       	eor	r1, r1
  32:	1f be       	out	0x3f, r1	; 63
  34:	cf e5       	ldi	r28, 0x5F	; 95
  36:	d2 e0       	ldi	r29, 0x02	; 2
  38:	de bf       	out	0x3e, r29	; 62
  3a:	cd bf       	out	0x3d, r28	; 61

0000003c <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  3c:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  3e:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  40:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2445
  42:	01 c0       	rjmp	.+2      	; 0x46 <.do_clear_bss_start>

00000044 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2447
  44:	1d 92       	st	X+, r1

00000046 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  46:	af 36       	cpi	r26, 0x6F	; 111
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  48:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2451
  4a:	e1 f7       	brne	.-8      	; 0x44 <.do_clear_bss_loop>
.do_clear_bss_start():
  4c:	e6 d0       	rcall	.+460    	; 0x21a <main>
  4e:	e1 c1       	rjmp	.+962    	; 0x412 <_exit>

00000050 <__bad_interrupt>:
__vector_1():
  50:	d7 cf       	rjmp	.-82     	; 0x0 <__vectors>

00000052 <digitalWrite.constprop.3>:
digitalWrite.constprop.3():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:117

}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t bit = digitalPinToBitMask(pin);
  52:	eb e2       	ldi	r30, 0x2B	; 43
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	94 91       	lpm	r25, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:118
	uint8_t port = digitalPinToPort(pin);
  58:	e5 e2       	ldi	r30, 0x25	; 37
  5a:	f0 e0       	ldi	r31, 0x00	; 0
  5c:	e4 91       	lpm	r30, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:121
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
  5e:	ee 23       	and	r30, r30
  60:	c9 f0       	breq	.+50     	; 0x94 <digitalWrite.constprop.3+0x42>
Timer0_SetCompareOutputModeB():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:792
  TCCR0A = (TCCR0A & ~MASK2(COM0A1,COM0A0)) | (com << COM0A0);
}

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeB( timer0_com_t com )
{
  TCCR0A = (TCCR0A & ~MASK2(COM0B1,COM0B0)) | (com << COM0B0);
  62:	2a b5       	in	r18, 0x2a	; 42
  64:	2f 7c       	andi	r18, 0xCF	; 207
  66:	2a bd       	out	0x2a, r18	; 42
digitalWrite.constprop.3():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:127

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
  turnOffPWM( pin );

	out = portOutputRegister(port);
  68:	f0 e0       	ldi	r31, 0x00	; 0
  6a:	ee 5d       	subi	r30, 0xDE	; 222
  6c:	ff 4f       	sbci	r31, 0xFF	; 255
  6e:	a4 91       	lpm	r26, Z
  70:	b0 e0       	ldi	r27, 0x00	; 0
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:129

	if (val == LOW) {
  72:	81 11       	cpse	r24, r1
  74:	09 c0       	rjmp	.+18     	; 0x88 <digitalWrite.constprop.3+0x36>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:130
		uint8_t oldSREG = SREG;
  76:	2f b7       	in	r18, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:131
    cli();
  78:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:132
		*out &= ~bit;
  7a:	8c 91       	ld	r24, X
  7c:	e9 2f       	mov	r30, r25
  7e:	e0 95       	com	r30
  80:	e8 23       	and	r30, r24
  82:	ec 93       	st	X, r30
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:133
		SREG = oldSREG;
  84:	2f bf       	out	0x3f, r18	; 63
  86:	08 95       	ret
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:135
	} else {
		uint8_t oldSREG = SREG;
  88:	8f b7       	in	r24, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:136
    cli();
  8a:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:137
		*out |= bit;
  8c:	ec 91       	ld	r30, X
  8e:	e9 2b       	or	r30, r25
  90:	ec 93       	st	X, r30
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:138
		SREG = oldSREG;
  92:	8f bf       	out	0x3f, r24	; 63
  94:	08 95       	ret

00000096 <pinMode>:
pinMode():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:35
#include "core_pins.h"
#include "core_timers.h"
#include "PwmTimer.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  96:	cf 93       	push	r28
  98:	df 93       	push	r29
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:36
	uint8_t bit = digitalPinToBitMask(pin);
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	fc 01       	movw	r30, r24
  9e:	e6 5d       	subi	r30, 0xD6	; 214
  a0:	ff 4f       	sbci	r31, 0xFF	; 255
  a2:	24 91       	lpm	r18, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:37
	uint8_t port = digitalPinToPort(pin);
  a4:	fc 01       	movw	r30, r24
  a6:	ec 5d       	subi	r30, 0xDC	; 220
  a8:	ff 4f       	sbci	r31, 0xFF	; 255
  aa:	84 91       	lpm	r24, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:40
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
  ac:	88 23       	and	r24, r24
  ae:	59 f1       	breq	.+86     	; 0x106 <pinMode+0x70>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:43

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
  b0:	90 e0       	ldi	r25, 0x00	; 0
  b2:	fc 01       	movw	r30, r24
  b4:	e0 5e       	subi	r30, 0xE0	; 224
  b6:	ff 4f       	sbci	r31, 0xFF	; 255
  b8:	e4 91       	lpm	r30, Z
  ba:	ce 2f       	mov	r28, r30
  bc:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:44
	out = portOutputRegister(port);
  be:	fc 01       	movw	r30, r24
  c0:	ee 5d       	subi	r30, 0xDE	; 222
  c2:	ff 4f       	sbci	r31, 0xFF	; 255
  c4:	84 91       	lpm	r24, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:46

	if (mode == INPUT) { 
  c6:	61 11       	cpse	r22, r1
  c8:	08 c0       	rjmp	.+16     	; 0xda <pinMode+0x44>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:47
		uint8_t oldSREG = SREG;
  ca:	9f b7       	in	r25, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:48
		cli();
  cc:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:49
		*reg &= ~bit;
  ce:	88 81       	ld	r24, Y
  d0:	e2 2f       	mov	r30, r18
  d2:	e0 95       	com	r30
  d4:	e8 23       	and	r30, r24
  d6:	e8 83       	st	Y, r30
  d8:	0e c0       	rjmp	.+28     	; 0xf6 <pinMode+0x60>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:51
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
  da:	62 30       	cpi	r22, 0x02	; 2
  dc:	71 f4       	brne	.+28     	; 0xfa <pinMode+0x64>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:44

	if (port == NOT_A_PIN) return;

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
	out = portOutputRegister(port);
  de:	a8 2f       	mov	r26, r24
  e0:	b0 e0       	ldi	r27, 0x00	; 0
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:52
		uint8_t oldSREG = SREG;
		cli();
		*reg &= ~bit;
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
		uint8_t oldSREG = SREG;
  e2:	9f b7       	in	r25, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:53
                cli();
  e4:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:54
		*reg &= ~bit;
  e6:	88 81       	ld	r24, Y
  e8:	32 2f       	mov	r19, r18
  ea:	30 95       	com	r19
  ec:	83 23       	and	r24, r19
  ee:	88 83       	st	Y, r24
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:55
		*out |= bit;
  f0:	ec 91       	ld	r30, X
  f2:	e2 2b       	or	r30, r18
  f4:	ec 93       	st	X, r30
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:56
		SREG = oldSREG;
  f6:	9f bf       	out	0x3f, r25	; 63
  f8:	06 c0       	rjmp	.+12     	; 0x106 <pinMode+0x70>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:58
	} else {
		uint8_t oldSREG = SREG;
  fa:	8f b7       	in	r24, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:59
		cli();
  fc:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:60
		*reg |= bit;
  fe:	e8 81       	ld	r30, Y
 100:	e2 2b       	or	r30, r18
 102:	e8 83       	st	Y, r30
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:61
		SREG = oldSREG;
 104:	8f bf       	out	0x3f, r24	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:63
	}
}
 106:	df 91       	pop	r29
 108:	cf 91       	pop	r28
 10a:	08 95       	ret

0000010c <micros>:
micros():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:143
}

unsigned long micros() 
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 10c:	3f b7       	in	r19, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:145
  
  cli();
 10e:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:146
  m = millis_timer_overflow_count;
 110:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <millis_timer_overflow_count>
 114:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <millis_timer_overflow_count+0x1>
 118:	a0 91 6d 00 	lds	r26, 0x006D	; 0x80006d <millis_timer_overflow_count+0x2>
 11c:	b0 91 6e 00 	lds	r27, 0x006E	; 0x80006e <millis_timer_overflow_count+0x3>
Timer1_GetCount():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:1029
  TIMSK |= (1<<TOIE1);
} 

__attribute__((always_inline)) static inline timer1_tcnt_t Timer1_GetCount( void )
{
  return( TCNT1 );
 120:	2f b5       	in	r18, 0x2f	; 47
micros():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:149
  t = MillisTimer_GetCount();
  
  if (MillisTimer_IsOverflowSet() && (t < 255))
 122:	08 b6       	in	r0, 0x38	; 56
 124:	02 fe       	sbrs	r0, 2
 126:	05 c0       	rjmp	.+10     	; 0x132 <micros+0x26>
 128:	2f 3f       	cpi	r18, 0xFF	; 255
 12a:	19 f0       	breq	.+6      	; 0x132 <micros+0x26>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:150
    m++;
 12c:	01 96       	adiw	r24, 0x01	; 1
 12e:	a1 1d       	adc	r26, r1
 130:	b1 1d       	adc	r27, r1
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:152

  SREG = oldSREG;
 132:	3f bf       	out	0x3f, r19	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:155
  
#if (MillisTimer_Prescale_Value >= clockCyclesPerMicrosecond())
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 134:	ba 2f       	mov	r27, r26
 136:	a9 2f       	mov	r26, r25
 138:	98 2f       	mov	r25, r24
 13a:	88 27       	eor	r24, r24
 13c:	82 0f       	add	r24, r18
 13e:	91 1d       	adc	r25, r1
 140:	a1 1d       	adc	r26, r1
 142:	b1 1d       	adc	r27, r1
 144:	bc 01       	movw	r22, r24
 146:	cd 01       	movw	r24, r26
 148:	42 e0       	ldi	r20, 0x02	; 2
 14a:	66 0f       	add	r22, r22
 14c:	77 1f       	adc	r23, r23
 14e:	88 1f       	adc	r24, r24
 150:	99 1f       	adc	r25, r25
 152:	4a 95       	dec	r20
 154:	d1 f7       	brne	.-12     	; 0x14a <micros+0x3e>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:159
#else
  return ((m << 8) + t) / (clockCyclesPerMicrosecond() / MillisTimer_Prescale_Value);
#endif
}
 156:	08 95       	ret

00000158 <analogWrite.constprop.1>:
analogWrite.constprop.1():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:69

// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
 158:	cf 93       	push	r28
 15a:	df 93       	push	r29
 15c:	ec 01       	movw	r28, r24
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:76
  // We need to make sure the PWM output is enabled for those pins
  // that support it, as we turn it off when digitally reading or
  // writing with them.  Also, make sure the pin is in output mode
  // for consistenty with Wiring, which doesn't require a pinMode
  // call for the analog output pins.
  pinMode(pin, OUTPUT);
 15e:	61 e0       	ldi	r22, 0x01	; 1
 160:	81 e0       	ldi	r24, 0x01	; 1
 162:	99 df       	rcall	.-206    	; 0x96 <pinMode>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:78

  if (val <= 0)
 164:	1c 16       	cp	r1, r28
 166:	1d 06       	cpc	r1, r29
 168:	14 f0       	brlt	.+4      	; 0x16e <analogWrite.constprop.1+0x16>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:80
  {
    digitalWrite(pin, LOW);
 16a:	80 e0       	ldi	r24, 0x00	; 0
 16c:	04 c0       	rjmp	.+8      	; 0x176 <analogWrite.constprop.1+0x1e>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:82
  }
  else if (val >= 255)
 16e:	cf 3f       	cpi	r28, 0xFF	; 255
 170:	d1 05       	cpc	r29, r1
 172:	24 f0       	brlt	.+8      	; 0x17c <analogWrite.constprop.1+0x24>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:84
  {
    digitalWrite(pin, HIGH);
 174:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:140
        digitalWrite(pin, HIGH);
      }
    }

  }
}
 176:	df 91       	pop	r29
 178:	cf 91       	pop	r28
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:84
  {
    digitalWrite(pin, LOW);
  }
  else if (val >= 255)
  {
    digitalWrite(pin, HIGH);
 17a:	6b cf       	rjmp	.-298    	; 0x52 <digitalWrite.constprop.3>
Timer0_SetCompareOutputModeB():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:792
  TCCR0A = (TCCR0A & ~MASK2(COM0A1,COM0A0)) | (com << COM0A0);
}

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeB( timer0_com_t com )
{
  TCCR0A = (TCCR0A & ~MASK2(COM0B1,COM0B0)) | (com << COM0B0);
 17c:	8a b5       	in	r24, 0x2a	; 42
 17e:	8f 7c       	andi	r24, 0xCF	; 207
 180:	80 62       	ori	r24, 0x20	; 32
 182:	8a bd       	out	0x2a, r24	; 42
Timer0_SetOutputCompareMatchB():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:818
  OCR0A = oc;
}

__attribute__((always_inline)) static inline void Timer0_SetOutputCompareMatchB( timer0_ocr_t oc )
{
  OCR0B = oc;
 184:	c8 bd       	out	0x28, r28	; 40
analogWrite.constprop.1():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_analog.c:140
        digitalWrite(pin, HIGH);
      }
    }

  }
}
 186:	df 91       	pop	r29
 188:	cf 91       	pop	r28
 18a:	08 95       	ret

0000018c <__vector_4>:
__vector_4():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:93
volatile unsigned long millis_timer_millis = 0;
static unsigned char millis_timer_fract = 0;

// bluebie changed isr to noblock so it wouldn't mess up USB libraries
ISR(MILLISTIMER_OVF_vect, ISR_NOBLOCK)
{
 18c:	78 94       	sei
 18e:	1f 92       	push	r1
 190:	0f 92       	push	r0
 192:	0f b6       	in	r0, 0x3f	; 63
 194:	0f 92       	push	r0
 196:	11 24       	eor	r1, r1
 198:	2f 93       	push	r18
 19a:	3f 93       	push	r19
 19c:	8f 93       	push	r24
 19e:	9f 93       	push	r25
 1a0:	af 93       	push	r26
 1a2:	bf 93       	push	r27
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:96
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 1a4:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <millis_timer_millis>
 1a8:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <millis_timer_millis+0x1>
 1ac:	a0 91 69 00 	lds	r26, 0x0069	; 0x800069 <millis_timer_millis+0x2>
 1b0:	b0 91 6a 00 	lds	r27, 0x006A	; 0x80006a <millis_timer_millis+0x3>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:97
  unsigned char f = millis_timer_fract;
 1b4:	30 91 66 00 	lds	r19, 0x0066	; 0x800066 <millis_timer_fract>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:109
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 1b8:	2c e7       	ldi	r18, 0x7C	; 124
 1ba:	23 0f       	add	r18, r19
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:111
  
  if (f >= FRACT_MAX) 
 1bc:	2d 37       	cpi	r18, 0x7D	; 125
 1be:	28 f0       	brcs	.+10     	; 0x1ca <__vector_4+0x3e>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:113
  {
    f -= FRACT_MAX;
 1c0:	2f ef       	ldi	r18, 0xFF	; 255
 1c2:	23 0f       	add	r18, r19
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:114
    m = m + MILLIS_INC + 1;
 1c4:	01 96       	adiw	r24, 0x01	; 1
 1c6:	a1 1d       	adc	r26, r1
 1c8:	b1 1d       	adc	r27, r1
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:121
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 1ca:	20 93 66 00 	sts	0x0066, r18	; 0x800066 <millis_timer_fract>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:122
  millis_timer_millis = m;
 1ce:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <millis_timer_millis>
 1d2:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <millis_timer_millis+0x1>
 1d6:	a0 93 69 00 	sts	0x0069, r26	; 0x800069 <millis_timer_millis+0x2>
 1da:	b0 93 6a 00 	sts	0x006A, r27	; 0x80006a <millis_timer_millis+0x3>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:123
  millis_timer_overflow_count++;
 1de:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <millis_timer_overflow_count>
 1e2:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <millis_timer_overflow_count+0x1>
 1e6:	a0 91 6d 00 	lds	r26, 0x006D	; 0x80006d <millis_timer_overflow_count+0x2>
 1ea:	b0 91 6e 00 	lds	r27, 0x006E	; 0x80006e <millis_timer_overflow_count+0x3>
 1ee:	01 96       	adiw	r24, 0x01	; 1
 1f0:	a1 1d       	adc	r26, r1
 1f2:	b1 1d       	adc	r27, r1
 1f4:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <millis_timer_overflow_count>
 1f8:	90 93 6c 00 	sts	0x006C, r25	; 0x80006c <millis_timer_overflow_count+0x1>
 1fc:	a0 93 6d 00 	sts	0x006D, r26	; 0x80006d <millis_timer_overflow_count+0x2>
 200:	b0 93 6e 00 	sts	0x006E, r27	; 0x80006e <millis_timer_overflow_count+0x3>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:124
}
 204:	bf 91       	pop	r27
 206:	af 91       	pop	r26
 208:	9f 91       	pop	r25
 20a:	8f 91       	pop	r24
 20c:	3f 91       	pop	r19
 20e:	2f 91       	pop	r18
 210:	0f 90       	pop	r0
 212:	0f be       	out	0x3f, r0	; 63
 214:	0f 90       	pop	r0
 216:	1f 90       	pop	r1
 218:	18 95       	reti

0000021a <main>:
main():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:339
      #warning "Cannot prescale chip to specified F_CPU speed"
    #endif
  #endif
  
  // this needs to be called before setup() or some functions won't work there
  sei();
 21a:	78 94       	sei
Timer1_SetWaveformGenerationMode():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:955
}
timer1_wgm_t;

__attribute__((always_inline)) static inline void Timer1_SetWaveformGenerationMode( timer1_wgm_t wgm )
{
  TCCR1 = (TCCR1 & ~MASK1(CTC1)) | ((wgm & 0x1) << CTC1);
 21c:	80 b7       	in	r24, 0x30	; 48
 21e:	80 68       	ori	r24, 0x80	; 128
 220:	80 bf       	out	0x30, r24	; 48
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:959

  if ( wgm & _Timer1_Enable_PWM_Mask )
  {
    TCCR1 |= MASK1(PWM1A);
 222:	80 b7       	in	r24, 0x30	; 48
 224:	80 64       	ori	r24, 0x40	; 64
 226:	80 bf       	out	0x30, r24	; 48
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:960
    GTCCR |= MASK1(PWM1B);
 228:	8c b5       	in	r24, 0x2c	; 44
 22a:	80 64       	ori	r24, 0x40	; 64
 22c:	8c bd       	out	0x2c, r24	; 44
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:965
  }

  if ( wgm & _Timer1_Set_OCRnC_To_FF_Mask )
  {
    OCR1C = 0xFF;
 22e:	8f ef       	ldi	r24, 0xFF	; 255
 230:	8d bd       	out	0x2d, r24	; 45
Timer1_ClockSelect():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:933
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1 = (TCCR1 & ~MASK4(CS13,CS12,CS11,CS10)) | (cs << CS10);
 232:	80 b7       	in	r24, 0x30	; 48
 234:	80 7f       	andi	r24, 0xF0	; 240
 236:	87 60       	ori	r24, 0x07	; 7
 238:	80 bf       	out	0x30, r24	; 48
Timer1_EnableOverflowInterrupt():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:1024
  TIMSK |= (1<<OCIE1A);
} 

__attribute__((always_inline)) static inline void Timer1_EnableOverflowInterrupt( void )
{
  TIMSK |= (1<<TOIE1);
 23a:	89 b7       	in	r24, 0x39	; 57
 23c:	84 60       	ori	r24, 0x04	; 4
 23e:	89 bf       	out	0x39, r24	; 57
Timer0_ClockSelect():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:754
}
timer0_cs_t;

__attribute__((always_inline)) static inline void Timer0_ClockSelect( timer0_cs_t cs )
{
  TCCR0B = (TCCR0B & ~MASK3(CS02,CS01,CS00)) | (cs << CS00);
 240:	83 b7       	in	r24, 0x33	; 51
 242:	88 7f       	andi	r24, 0xF8	; 248
 244:	83 bf       	out	0x33, r24	; 51
Timer0_SetWaveformGenerationMode():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:772
}
timer0_wgm_t;

__attribute__((always_inline)) static inline void Timer0_SetWaveformGenerationMode( timer0_wgm_t wgm )
{
  TCCR0A = (TCCR0A & ~MASK2(WGM01,WGM00)) | (((wgm & B011) >> 0) << WGM00);
 246:	8a b5       	in	r24, 0x2a	; 42
 248:	8c 7f       	andi	r24, 0xFC	; 252
 24a:	81 60       	ori	r24, 0x01	; 1
 24c:	8a bd       	out	0x2a, r24	; 42
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:773
  TCCR0B = (TCCR0B & ~MASK1(WGM02))       | (((wgm & B100) >> 2) << WGM02);
 24e:	83 b7       	in	r24, 0x33	; 51
 250:	87 7f       	andi	r24, 0xF7	; 247
 252:	83 bf       	out	0x33, r24	; 51
Timer0_ClockSelect():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:754
}
timer0_cs_t;

__attribute__((always_inline)) static inline void Timer0_ClockSelect( timer0_cs_t cs )
{
  TCCR0B = (TCCR0B & ~MASK3(CS02,CS01,CS00)) | (cs << CS00);
 254:	83 b7       	in	r24, 0x33	; 51
 256:	88 7f       	andi	r24, 0xF8	; 248
 258:	83 60       	ori	r24, 0x03	; 3
 25a:	83 bf       	out	0x33, r24	; 51
ADC_PrescalerSelect():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_adc.h:82
}
adc_ps_t;

__attribute__((always_inline)) static inline void ADC_PrescalerSelect( adc_ps_t ps )
{
  ADCSRA = (ADCSRA & ~MASK3(ADPS2,ADPS1,ADPS0)) | (ps << ADPS0);
 25c:	86 b1       	in	r24, 0x06	; 6
 25e:	87 60       	ori	r24, 0x07	; 7
 260:	86 b9       	out	0x06, r24	; 6
ADC_Enable():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_adc.h:87
}

__attribute__((always_inline)) static inline void ADC_Enable( void )
{
  ADCSRA |= MASK1( ADEN );
 262:	37 9a       	sbi	0x06, 7	; 6
setup():
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:68
void setup() {
/*  
 *  Read in the saved preset tail light brightness value
 *  from chips EEPROM address 1 into the static variable brightness
 */
    brightness = eeprom_read_byte ((uint8_t *)1);
 264:	81 e0       	ldi	r24, 0x01	; 1
 266:	90 e0       	ldi	r25, 0x00	; 0
 268:	ba d0       	rcall	.+372    	; 0x3de <eeprom_read_byte>
 26a:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <brightness>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:70
/* change PWM counter 0 prescaler from default 3 to 4 to slow down the default PWM 0 frequency by 4 to better suit solid state relay chip when running at 16MHz */
    TCCR0B = 4;
 26e:	84 e0       	ldi	r24, 0x04	; 4
 270:	83 bf       	out	0x33, r24	; 51
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:71
    analogWrite(brightnessPin, brightness); // why wait for loop() all the rest is user interface, power reduction and potential clock fiddling
 272:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <brightness>
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	6f df       	rcall	.-290    	; 0x158 <analogWrite.constprop.1>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:72
    pinMode(ButtonPin, INPUT_PULLUP);
 27a:	62 e0       	ldi	r22, 0x02	; 2
 27c:	83 e0       	ldi	r24, 0x03	; 3
 27e:	0b df       	rcall	.-490    	; 0x96 <pinMode>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:78
/* 
 * adjacent input pin will be tied to ButtonPin on production PCB leaving it pulled to logic 1 so that the cpu is down clocked to reduce EMI and pointless fast processing
 * unless the chip is in a dev boards socket OR in the production board with the button pressed during power up, in that case it stays at 16MHz so default ISP settings 
 * work flawlessly while debugging or upgrading firmware with IC pin clips wired to an ISP.
 */
    pinMode(ButtonPin + 1,INPUT);
 280:	60 e0       	ldi	r22, 0x00	; 0
 282:	84 e0       	ldi	r24, 0x04	; 4
 284:	08 df       	rcall	.-496    	; 0x96 <pinMode>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:79
    ADCSRA = 0;  // disable ADC
 286:	16 b8       	out	0x06, r1	; 6
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:80
    PRR = 3; // power down ADC and USI peripherals
 288:	83 e0       	ldi	r24, 0x03	; 3
 28a:	80 bd       	out	0x20, r24	; 32
digitalRead():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:144
	}
}

int digitalRead(uint8_t pin)
{
	uint8_t bit = digitalPinToBitMask(pin);
 28c:	ee e2       	ldi	r30, 0x2E	; 46
 28e:	f0 e0       	ldi	r31, 0x00	; 0
 290:	84 91       	lpm	r24, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:145
	uint8_t port = digitalPinToPort(pin);
 292:	e8 e2       	ldi	r30, 0x28	; 40
 294:	f0 e0       	ldi	r31, 0x00	; 0
 296:	e4 91       	lpm	r30, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:147

	if (port == NOT_A_PIN) return LOW;
 298:	ee 23       	and	r30, r30
 29a:	61 f0       	breq	.+24     	; 0x2b4 <__stack+0x55>
Timer1_SetCompareOutputModeB():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/core_timers.h:985
  TCCR1 = (TCCR1 & ~MASK2(COM1A1,COM1A0)) | (com << COM1A0);
}

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeB( timer1_com_t com )
{
  GTCCR = (GTCCR & ~MASK2(COM1B1,COM1B0)) | (com << COM1B0);
 29c:	9c b5       	in	r25, 0x2c	; 44
 29e:	9f 7c       	andi	r25, 0xCF	; 207
 2a0:	9c bd       	out	0x2c, r25	; 44
digitalRead():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:153

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
  turnOffPWM( pin );

	if (*portInputRegister(port) & bit) return HIGH;
 2a2:	f0 e0       	ldi	r31, 0x00	; 0
 2a4:	e2 5e       	subi	r30, 0xE2	; 226
 2a6:	ff 4f       	sbci	r31, 0xFF	; 255
 2a8:	a4 91       	lpm	r26, Z
 2aa:	b0 e0       	ldi	r27, 0x00	; 0
 2ac:	ec 91       	ld	r30, X
 2ae:	e8 23       	and	r30, r24
 2b0:	09 f0       	breq	.+2      	; 0x2b4 <__stack+0x55>
 2b2:	7c c0       	rjmp	.+248    	; 0x3ac <__stack+0x14d>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:144
	}
}

int digitalRead(uint8_t pin)
{
	uint8_t bit = digitalPinToBitMask(pin);
 2b4:	cd e2       	ldi	r28, 0x2D	; 45
 2b6:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:145
	uint8_t port = digitalPinToPort(pin);
 2b8:	07 e2       	ldi	r16, 0x27	; 39
 2ba:	10 e0       	ldi	r17, 0x00	; 0
loop():
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:104
 * Adjusts and saves brightness level to EEPROM to preserve tail light brightness setting for next cold boot
 */
        if ((digitalRead(ButtonPin) == 0) && (millis() - timp > debounce)) 
        {
            brightness = brightness + brightup;
            changed = 1;
 2bc:	ff 24       	eor	r15, r15
 2be:	f3 94       	inc	r15
digitalRead():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:144
	}
}

int digitalRead(uint8_t pin)
{
	uint8_t bit = digitalPinToBitMask(pin);
 2c0:	fe 01       	movw	r30, r28
 2c2:	94 91       	lpm	r25, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:145
	uint8_t port = digitalPinToPort(pin);
 2c4:	f8 01       	movw	r30, r16
 2c6:	84 91       	lpm	r24, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:147

	if (port == NOT_A_PIN) return LOW;
 2c8:	88 23       	and	r24, r24
 2ca:	d1 f0       	breq	.+52     	; 0x300 <__stack+0xa1>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:153

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
  turnOffPWM( pin );

	if (*portInputRegister(port) & bit) return HIGH;
 2cc:	e8 2f       	mov	r30, r24
 2ce:	f0 e0       	ldi	r31, 0x00	; 0
 2d0:	e2 5e       	subi	r30, 0xE2	; 226
 2d2:	ff 4f       	sbci	r31, 0xFF	; 255
 2d4:	e4 91       	lpm	r30, Z
 2d6:	f0 e0       	ldi	r31, 0x00	; 0
 2d8:	80 81       	ld	r24, Z
 2da:	89 23       	and	r24, r25
 2dc:	89 f0       	breq	.+34     	; 0x300 <__stack+0xa1>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:144
	}
}

int digitalRead(uint8_t pin)
{
	uint8_t bit = digitalPinToBitMask(pin);
 2de:	fe 01       	movw	r30, r28
 2e0:	94 91       	lpm	r25, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:145
	uint8_t port = digitalPinToPort(pin);
 2e2:	f8 01       	movw	r30, r16
 2e4:	84 91       	lpm	r24, Z
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:147

	if (port == NOT_A_PIN) return LOW;
 2e6:	88 23       	and	r24, r24
 2e8:	09 f4       	brne	.+2      	; 0x2ec <__stack+0x8d>
 2ea:	44 c0       	rjmp	.+136    	; 0x374 <__stack+0x115>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring_digital.c:153

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
  turnOffPWM( pin );

	if (*portInputRegister(port) & bit) return HIGH;
 2ec:	e8 2f       	mov	r30, r24
 2ee:	f0 e0       	ldi	r31, 0x00	; 0
 2f0:	e2 5e       	subi	r30, 0xE2	; 226
 2f2:	ff 4f       	sbci	r31, 0xFF	; 255
 2f4:	e4 91       	lpm	r30, Z
 2f6:	f0 e0       	ldi	r31, 0x00	; 0
 2f8:	80 81       	ld	r24, Z
 2fa:	89 23       	and	r24, r25
 2fc:	d9 f1       	breq	.+118    	; 0x374 <__stack+0x115>
 2fe:	61 c0       	rjmp	.+194    	; 0x3c2 <__stack+0x163>
millis():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:129
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
 300:	2f b7       	in	r18, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:133

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
 302:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:134
  m = millis_timer_millis;
 304:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <millis_timer_millis>
 308:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <millis_timer_millis+0x1>
 30c:	a0 91 69 00 	lds	r26, 0x0069	; 0x800069 <millis_timer_millis+0x2>
 310:	b0 91 6a 00 	lds	r27, 0x006A	; 0x80006a <millis_timer_millis+0x3>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:135
  SREG = oldSREG;
 314:	2f bf       	out	0x3f, r18	; 63
loop():
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:101

void loop() {
/* 
 * Adjusts and saves brightness level to EEPROM to preserve tail light brightness setting for next cold boot
 */
        if ((digitalRead(ButtonPin) == 0) && (millis() - timp > debounce)) 
 316:	40 91 62 00 	lds	r20, 0x0062	; 0x800062 <timp>
 31a:	50 91 63 00 	lds	r21, 0x0063	; 0x800063 <timp+0x1>
 31e:	60 91 64 00 	lds	r22, 0x0064	; 0x800064 <timp+0x2>
 322:	70 91 65 00 	lds	r23, 0x0065	; 0x800065 <timp+0x3>
 326:	84 1b       	sub	r24, r20
 328:	95 0b       	sbc	r25, r21
 32a:	a6 0b       	sbc	r26, r22
 32c:	b7 0b       	sbc	r27, r23
 32e:	85 36       	cpi	r24, 0x65	; 101
 330:	91 05       	cpc	r25, r1
 332:	a1 05       	cpc	r26, r1
 334:	b1 05       	cpc	r27, r1
 336:	98 f2       	brcs	.-90     	; 0x2de <__stack+0x7f>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:103
        {
            brightness = brightness + brightup;
 338:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <brightness>
 33c:	8f 5f       	subi	r24, 0xFF	; 255
 33e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <brightness>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:104
            changed = 1;
 342:	f0 92 60 00 	sts	0x0060, r15	; 0x800060 <_edata>
millis():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:129
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
 346:	2f b7       	in	r18, 0x3f	; 63
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:133

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
 348:	f8 94       	cli
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:134
  m = millis_timer_millis;
 34a:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <millis_timer_millis>
 34e:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <millis_timer_millis+0x1>
 352:	a0 91 69 00 	lds	r26, 0x0069	; 0x800069 <millis_timer_millis+0x2>
 356:	b0 91 6a 00 	lds	r27, 0x006A	; 0x80006a <millis_timer_millis+0x3>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:135
  SREG = oldSREG;
 35a:	2f bf       	out	0x3f, r18	; 63
loop():
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:105
            timp = millis();
 35c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <timp>
 360:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <timp+0x1>
 364:	a0 93 64 00 	sts	0x0064, r26	; 0x800064 <timp+0x2>
 368:	b0 93 65 00 	sts	0x0065, r27	; 0x800065 <timp+0x3>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:106
            analogWrite(brightnessPin, brightness);
 36c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <brightness>
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	f2 de       	rcall	.-540    	; 0x158 <analogWrite.constprop.1>
delay():
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:163
#endif
}

void delay(unsigned long ms)
{
  uint16_t start = (uint16_t)micros();
 374:	cb de       	rcall	.-618    	; 0x10c <micros>
 376:	6b 01       	movw	r12, r22
 378:	82 e3       	ldi	r24, 0x32	; 50
 37a:	88 2e       	mov	r8, r24
 37c:	91 2c       	mov	r9, r1
 37e:	a1 2c       	mov	r10, r1
 380:	b1 2c       	mov	r11, r1
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:166

  while (ms > 0) {
    if (((uint16_t)micros() - start) >= 1000) {
 382:	c4 de       	rcall	.-632    	; 0x10c <micros>
 384:	6c 19       	sub	r22, r12
 386:	7d 09       	sbc	r23, r13
 388:	68 3e       	cpi	r22, 0xE8	; 232
 38a:	73 40       	sbci	r23, 0x03	; 3
 38c:	d0 f3       	brcs	.-12     	; 0x382 <__stack+0x123>
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:167
      ms--;
 38e:	81 e0       	ldi	r24, 0x01	; 1
 390:	88 1a       	sub	r8, r24
 392:	91 08       	sbc	r9, r1
 394:	a1 08       	sbc	r10, r1
 396:	b1 08       	sbc	r11, r1
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:168
      start += 1000;
 398:	e8 e1       	ldi	r30, 0x18	; 24
 39a:	ce 1a       	sub	r12, r30
 39c:	ec ef       	ldi	r30, 0xFC	; 252
 39e:	de 0a       	sbc	r13, r30
C:\Users\WINDOWS\AppData\Local\Arduino15\packages\digistump\hardware\avr\1.6.7\cores\tiny/wiring.c:165

void delay(unsigned long ms)
{
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
 3a0:	81 14       	cp	r8, r1
 3a2:	91 04       	cpc	r9, r1
 3a4:	a1 04       	cpc	r10, r1
 3a6:	b1 04       	cpc	r11, r1
 3a8:	61 f7       	brne	.-40     	; 0x382 <__stack+0x123>
 3aa:	8a cf       	rjmp	.-236    	; 0x2c0 <__stack+0x61>
setup():
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:87
 * This following section is to allow development using an ISP and not micronucleus firmware programmer in socketed dev board 
 * Or in protype board or final circuit without custom avardude settings if button is pressed during power up.
 */
    if (digitalRead(ButtonPin + 1) == 1) // If pin 2 linked to pin 3 otherwise called PB3 and PB4 are connected together and not pulled down to logic zero using the button
    { // downclock to 0.0625MHz and tweak Counter0 and Counter1 to set desired PWM frequency
      cli(); // Disable interrupts (not sure if any interupts are used by the runtimes but just in case these are included to avoid unforseeable problems)
 3ac:	f8 94       	cli
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:88
      CLKPR = 128; //  (1<<CLKPCE) // Prescaler enable
 3ae:	80 e8       	ldi	r24, 0x80	; 128
 3b0:	86 bd       	out	0x26, r24	; 38
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:89
      CLKPR = 8; // Clock division factor 256 (1000) divisor code n is encoded 2 the power of n with max divisor code of 8
 3b2:	88 e0       	ldi	r24, 0x08	; 8
 3b4:	86 bd       	out	0x26, r24	; 38
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:90
      sei(); // Enable interrupts
 3b6:	78 94       	sei
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:92
/* change PWM counter 0 prescaler register from 3 to 1 to increase PWM 0 operating frequency by 16 to better suit sold state relay chip when running at 0.0625MHz */
      TCCR0B = 1; // 1 is optimal 122Hz
 3b8:	81 e0       	ldi	r24, 0x01	; 1
 3ba:	83 bf       	out	0x33, r24	; 51
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:93
      TCCR1 = 65;
 3bc:	81 e4       	ldi	r24, 0x41	; 65
 3be:	80 bf       	out	0x30, r24	; 48
 3c0:	79 cf       	rjmp	.-270    	; 0x2b4 <__stack+0x55>
loop():
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:108
            brightness = brightness + brightup;
            changed = 1;
            timp = millis();
            analogWrite(brightnessPin, brightness);
        } 
        else if (digitalRead(ButtonPin) == 1 && changed == 1)
 3c2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 3c6:	81 30       	cpi	r24, 0x01	; 1
 3c8:	a9 f6       	brne	.-86     	; 0x374 <__stack+0x115>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:110
        { // only when button is released AND brightness was changed write eeprom address 1 if there is a new value of brightness to preset new brightness on next boot up
          cli();
 3ca:	f8 94       	cli
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:111
          eeprom_update_byte ((uint8_t *)1, brightness);
 3cc:	60 91 61 00 	lds	r22, 0x0061	; 0x800061 <brightness>
 3d0:	81 e0       	ldi	r24, 0x01	; 1
 3d2:	90 e0       	ldi	r25, 0x00	; 0
 3d4:	0c d0       	rcall	.+24     	; 0x3ee <eeprom_update_byte>
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:112
          sei();
 3d6:	78 94       	sei
C:\WINDOWS\Users1\Users\WINDOWS\Downloads\Adjustable_Brake_light_dimmer-master\Adjustable_Brake_light_dimmer/Adjustable_Brake_light_dimmer.ino:113
          changed = 0;
 3d8:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
 3dc:	cb cf       	rjmp	.-106    	; 0x374 <__stack+0x115>

000003de <eeprom_read_byte>:
eeprom_read_byte():
 3de:	e1 99       	sbic	0x1c, 1	; 28
 3e0:	fe cf       	rjmp	.-4      	; 0x3de <eeprom_read_byte>
 3e2:	9f bb       	out	0x1f, r25	; 31
 3e4:	8e bb       	out	0x1e, r24	; 30
 3e6:	e0 9a       	sbi	0x1c, 0	; 28
 3e8:	99 27       	eor	r25, r25
 3ea:	8d b3       	in	r24, 0x1d	; 29
 3ec:	08 95       	ret

000003ee <eeprom_update_byte>:
eeprom_update_byte():
 3ee:	26 2f       	mov	r18, r22

000003f0 <eeprom_update_r18>:
 3f0:	e1 99       	sbic	0x1c, 1	; 28
 3f2:	fe cf       	rjmp	.-4      	; 0x3f0 <eeprom_update_r18>
 3f4:	9f bb       	out	0x1f, r25	; 31
 3f6:	8e bb       	out	0x1e, r24	; 30
 3f8:	e0 9a       	sbi	0x1c, 0	; 28
 3fa:	01 97       	sbiw	r24, 0x01	; 1
 3fc:	0d b2       	in	r0, 0x1d	; 29
 3fe:	02 16       	cp	r0, r18
 400:	39 f0       	breq	.+14     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 402:	1c ba       	out	0x1c, r1	; 28
 404:	2d bb       	out	0x1d, r18	; 29
 406:	0f b6       	in	r0, 0x3f	; 63
 408:	f8 94       	cli
 40a:	e2 9a       	sbi	0x1c, 2	; 28
 40c:	e1 9a       	sbi	0x1c, 1	; 28
 40e:	0f be       	out	0x3f, r0	; 63
 410:	08 95       	ret

00000412 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2279
 412:	f8 94       	cli

00000414 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2281
 414:	ff cf       	rjmp	.-2      	; 0x414 <__stop_program>
